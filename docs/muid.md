# Muid Specification
This specification is heavily inspired by ULID
(https://github.com/ulid/spec) in that it intends to 
specify a scheme for identifiers that can be ordered,
increase over time, and very likely to be unique,
and fit into 128 bits.

Muids have some additional objectives, however.
For one, we'd like to be able to keep track of
the database node that created a given muid.
Each node in the database will only create objects
with a monotonically increasing time. 
We may not receive an update from a distant node until well
after it was created, so will have trouble keeping *all*
updates in order, but separating them out by node source
will allow us to keep the updates from each node in order by time.

Secondly we'd like to be able to specify that a set of updates
from a node should be treated as happening all together 
(in a single atomic transaction).  Since all of these updates
will share the same timestamp and node identifier, some additional
bits need to be used to distinguish between the various updates
within a transaction.  To ensure that all updates within one
transaction are either before or after all updates from another,
the order of components will be: [timestamp, medallion, offset].

# Timestamp
As the name implies, muids have microsecond time resolution.
The first 14 hex digits (7 bytes) of a muid should be the 
number of microseconds since epoch, encoded big-endian.
This will ensure that lexical comparisons of muids will sort
according to time.  As an example, I see the (fractional) unix time
as of this writing to be 1642579230.975519 (generated by python's time.time()).
That corresponds to 1642579230975519 microseconds with hex digits
`5D5EAC793E61F`.  That's only 13 hex digits but muid leaves room for 14,
so a leading 0 should be added to the beginning for
the cononical hex representation of that time: '05D5EAC793E61F'.
Microsecond timestamps through the year 4253 can be represented.


# Medallion
Each node in the system has a unique medallion to identify it.
Medallions are 52 bit integers.  A number of different schemes could be
used to assign these numbers, but for version 1, implementations should
randomly select numbers the range 
281474976710656 to 562949953421311 ('0x1000000000000' to '0x1FFFFFFFFFFFF').
Numbers in this range will always have exactly 13 hex digits.
For example, one medallion randomly selected from that range could be
417399343184351, which has the hex sequence '17B9F5B9479DF'.

# Offset
Only five hex digits remain for the offset, effectively bounding transactions
to have no more than roughly a million distinct objects each.  Additionally,
the offset "0" should be used to designate the transaction itself.
For example, one offset could be 608960 which has the hex digits "94AC0".

# Combined Cononical Representation
Concatenating all of the upper case hex digits in the order:
timestamp, medallion, offset together produces the cononical representation.
Though adding dashes or underscores between components would have made 
the representation marginally easier to read 
(e.g., wrong: "05D5EAC793E61F-17B9F5B9479DF-94AC0"), 
the dashes introduce problems for many systems that parse hex digits.
So the correct muid combining the examples from above 
should be "05D5EAC793E61F17B9F5B9479DF94AC0".
